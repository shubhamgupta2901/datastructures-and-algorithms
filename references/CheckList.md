### Contents
1. [STACKS](#)
  *  [Array Implementation of Stack]
  *  [LinkedList implementaion of Stack](#)
  *  [Implement a MinStack](#)
  *  [Implement a Stack using Queues](#)
  *  [Implement a Stack using using one Queue](#)
  *  [Reverse words of a String](#)
  *  [Check validity of expression having nested paranthesis](#)
  *  [Convert infix polish notation to prefix notation](#)

2. [QUEUES](#)
  *  [Array Implementation of Queue](#)
  *  [Efficient Array Implementation of Queue](#)
  *  [LinkedList Implementation of Queue](#)
  *  [Double ended queue implementation with array](#)
  *  [Implement a queue using stacks](#)

3. [SINGLE LINKED LIST](#single-linked-list)
  *  [Insert node in linked list: at beginning, after a given node, at last](#)
  *  [Delete node in linked list: first node, only node, b/w two nodes and, end of the list](#)
  *  [Nth node from the end of linked list(Two Pass and One Pass solution)](#)
  *  [Middle of the linked list](#)
  *  [Swap two nodes in linked list without changing data](#)
  *  [Reverse linked list non recursively and recursively](#)
  *  [Reverse a linked list from position m to n](#)
  *  [Intersection and Intersection Point in 2 Linked List](#)
  *  [Selection sort in linked list by exchanging nodes](#)
  *  [Insertion sort in linked list by exchanging nodes](#)
  *  [Detect loop and remove it in Linked list](#)
  *  [Union and Intersection of two linked lists](#)
  *  [Reverse LInked List in groups](#)
	
4. [DOUBLY LINKED LIST](#doubly-linked-list)
  *  [Create and traverse linked list](#)
  *  [Insert node in linked list: at beginning, after a given node](#)
  *  [Delete node in linked list: first node, only node, b/w two nodes and, end of the list](#)
  *  [Reverse linked list non recursively and recursively](#)
	
5. [CIRCULAR LINKED LIST](#circular-linked-list)
  *  [Implementation and Design Analysis](#)
  *  [Circular Linked List : Traversal](#)
  *  [Circular Linked List : Insertion](#)
  *  [Circular Linked List : Deletion](#)
  *  [Count the number of nodes in Circular Linked List](#)
	
6. [BINARY TREE](#binary-tree)
  *  [Structure of binary tree](#)
	*  [Iterative Preorder traversal of binary tree](#) 
	*  [Iterative Inorder traversal of binary tree](#)
	*  [Iterative PostOrder traversal of binary tree](#)
	*  [Insert, delete and search element in binary tree with time analysis](#)
	*  [Find Size and height of binary tree](#)
	*  [Levelorder Traversal of binary tree](#)
	*  [ZigZag Levelorder traversal](#)
	*  [Vertical Order Traversal](#)
	*  [Top view of binary tree](#)
	*  [Bottom Side view of binary tree](#)
	*  [Structuraly same and mirror binary trees](#)
	*  [Lowest Common Ancestor of two nodes in binary trees](#)
	*  [Right Side view of binary Tree](#)
	*  [Maximum width of binary tree](#)
	*  [Construct a Binary Tree from preorder and inorder traversal](#)
	
7. [BINARY SEARCH TREE](#)	
  *  [BST Property](#)
	*  [Search element in BST](#) 
	*  [Find minimum and maximum element in BST](#)
	*  [Inserting an element in BST](#)
	*  [Validate a BST](#)
	*  [Finding kth smallest/largest element in BST](#) 
	*  [Find Inorder predecessor and successor of BST](#)
	*  [Delete element from BST](#)
	*  [Lowest Common Ancestor of BST](#)
	
8. [BINARY HEAPS](#)
  *  [What is Priority Queue](#)
  *  [Key operations in Priority Queue - ```insert(), deleteMax(), extractMax()```](#)
  *  [Ways to implement Priority Queues and time and space analysis](#)
  *  [Binary Heaps and Implement Priority Queue with Binary Heaps](#)
  *  [Max-heapify an array in O(nlogn)](#)
  *  [Kth largest element in a stream.(BST vs Heap time analysis for ordered insertion)](#)
  *  [Heapify Up and Heapify Down methods](#)
  *  [Heapsort](#https://www.geeksforgeeks.org/heap-sort/)
	
9. [HASHMAPS](#)
  *  [Direct Access Table and its time and space analysis](#)
  *  [Two major issues with Direct Access Table](#)
  *  [Prehashing(Mapping non integer keys to a integer value) - hashCode()](#)
  *  [Hashing - Reducing the space of Direct Access Table - hash()](#)
  *  [Problem with Hashing- Collison](#)
  *  [Technique to handle collision - Chaining](#)
  *  [Time analysis and a sample hash function](#)
  *  [Implementation of hashmap in JAVA](#)
  *  [How does a hashmap grows and shrink](#)
  *  [equalTo() and hash() in JAVA](#)
  *  [Difference between HashMap and LinkedHashMap](#)
  *  [Internal representation of LinkedHashMap](#)
  *  [Internal representation of TreeHashMap](#)
	
10. [GRAPHS](#)
  *  [Representation Of graphs using Adjacency List](#)
  *  [Breadth First Search in O(V+E)](#)
  *  [Recreate shortest path by using parent pointer in BFS](#)
  *  [Depth First Search in O(V+E) Iterative](#)
  *  [Depth First Search in O(V+E) Recursive](#)
  *  [Detect Cycle in graphs](#)
  *  [Topological Sort](#)
